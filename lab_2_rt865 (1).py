# -*- coding: utf-8 -*-
"""Lab 2 rt865.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12-z4VIIUt3b1xDmUcnBtl2Or021m76sh
"""

import os, time, random
from dataclasses import dataclass

import numpy as np
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap

@dataclass
class Config:
    num_tasks: int = 5
    depth: int = 3
    hidden_units: int = 256
    dropout: float = 0.3
    seed: int = 42
    initial_epochs: int = 5
    epochs_per_task: int = 3
    batch_size: int = 64
    lr: float = 1e-3
    loss: str = "nll"
    opt: str = "adam"
    outdir: str = "/content/results"

args = Config()

os.makedirs(args.outdir, exist_ok=True)
tf.keras.utils.set_random_seed(args.seed)
np.random.seed(args.seed)
random.seed(args.seed)


(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()
x_train = (x_train.astype("float32") / 255.0).reshape((-1, 784))
x_test  = (x_test.astype("float32")  / 255.0).reshape((-1, 784))


def make_permuted_tasks(n_tasks: int):
    """Return a list of index permutations (one per task)."""
    return [np.random.permutation(784) for _ in range(n_tasks)]

tasks = make_permuted_tasks(args.num_tasks)


def build_mlp(input_dim: int, depth: int, units: int, dropout: float):
    """Functional API MLP."""
    inputs = keras.Input(shape=(input_dim,))
    x = inputs
    for _ in range(depth):
        x = layers.Dense(units, activation="relu")(x)
        if dropout > 0:
            x = layers.Dropout(dropout)(x)
    outputs = layers.Dense(10, activation="softmax")(x)
    return keras.Model(inputs, outputs, name="permMNIST_mlp")


def get_loss_fn(name: str):
    if name == "nll":
        return keras.losses.SparseCategoricalCrossentropy()
    if name == "l1":
        return keras.losses.MeanAbsoluteError()
    if name == "l2":
        return keras.losses.MeanSquaredError()
    if name == "l1+l2":
        def l1l2(y_true, y_pred):
            y_true_oh = tf.one_hot(tf.cast(y_true, tf.int32), depth=10)
            l1 = tf.reduce_mean(tf.abs(y_true_oh - y_pred))
            l2 = tf.reduce_mean(tf.square(y_true_oh - y_pred))
            return l1 + l2
        return l1l2
    raise ValueError(f"Unknown loss: {name}")

def get_optimizer(name: str, lr: float):
    name = name.lower()
    opts = {
        "sgd": keras.optimizers.SGD(learning_rate=lr),
        "adam": keras.optimizers.Adam(learning_rate=lr),
        "rmsprop": keras.optimizers.RMSprop(learning_rate=lr),
    }
    if name not in opts:
        raise ValueError(f"Unknown optimizer: {name}")
    return opts[name]


def compute_ACC(R: np.ndarray) -> float:
    """
    ACC = mean of the last row (assignment definition)
    = (1/T) * sum_j R[T-1, j]
    """
    T = R.shape[0]
    return float(np.mean(R[T - 1, :]))

def compute_BWT(R: np.ndarray) -> float:
    """
    BWT = (1/(T-1)) * sum_{j=0}^{T-2} ( R[T-1, j] - R[j, j] )
    """
    T = R.shape[0]
    if T < 2:
        return 0.0
    diffs = [R[T - 1, j] - R[j, j] for j in range(T - 1)]
    return float(np.mean(diffs))

def compute_TBWT(R: np.ndarray) -> float:
    """
    TBWT = average over all pairs i>j of ( R[i, j] - R[j, j] )
    """
    T = R.shape[0]
    s, c = 0.0, 0
    for i in range(1, T):
        for j in range(i):
            s += R[i, j] - R[j, j]
            c += 1
    return s / c if c > 0 else 0.0

def compute_CBWT(R: np.ndarray) -> float:
    """
    CBWT = (1/(T-1)) * sum_{i=1}^{T-1} ( R[i, i] - R[0, 0] )
    """
    T = R.shape[0]
    if T < 2:
        return 0.0
    s = 0.0
    for i in range(1, T):
        s += R[i, i] - R[0, 0]
    return s / (T - 1)


def run_experiment():
    model = build_mlp(784, args.depth, args.hidden_units, args.dropout)
    model.compile(
        optimizer=get_optimizer(args.opt, args.lr),
        loss=get_loss_fn(args.loss),
        metrics=["accuracy"],
    )

    R = np.zeros((args.num_tasks, args.num_tasks), dtype=float)

    for t, perm in enumerate(tasks):
        print(f"\n===== Training Task {t+1}/{args.num_tasks} =====")
        x_train_p = x_train[:, perm]
        x_test_p  = x_test[:, perm]
        epochs = args.initial_epochs if t == 0 else args.epochs_per_task

        model.fit(
            x_train_p, y_train,
            validation_data=(x_test_p, y_test),
            epochs=epochs,
            batch_size=args.batch_size,
            verbose=2,
        )


        for j, eval_perm in enumerate(tasks[: t + 1]):
            x_eval = x_test[:, eval_perm]
            _, acc = model.evaluate(x_eval, y_test, verbose=0)
            R[t, j] = acc

    return R


t0 = time.time()
acc_matrix = run_experiment()
print(f"\nTraining finished in {time.time() - t0:.2f}s")

ACC  = compute_ACC(acc_matrix)
BWT  = compute_BWT(acc_matrix)
TBWT = compute_TBWT(acc_matrix)
CBWT = compute_CBWT(acc_matrix)

print("\n===== Final Metrics =====")
print(f"ACC : {ACC:.4f}")
print(f"BWT : {BWT:.4f}")
print(f"TBWT: {TBWT:.4f}")
print(f"CBWT: {CBWT:.4f}")


LINE_COLORS = sns.color_palette("colorblind", n_colors=args.num_tasks)
HEAT_CMAP   = sns.color_palette("viridis", as_cmap=True)
BAR_COLORS  = ["#E69F00", "#56B4E9"]  # orange, sky blue


# Heatmap
plt.figure(figsize=(7, 6))
sns.heatmap(acc_matrix, annot=True, cmap=HEAT_CMAP, fmt=".3f",
            cbar_kws={"label": "Accuracy"})
plt.title("Accuracy Matrix R[i, j]")
plt.xlabel("Evaluated Task (j)")
plt.ylabel("After Training Task (i)")
plt.tight_layout()
plt.savefig(os.path.join(args.outdir, "accuracy_matrix_heatmap.png"), dpi=150)
plt.show()

# Forgetting curves
plt.figure(figsize=(7, 5))
xs = range(1, args.num_tasks + 1)
for i in range(args.num_tasks):
    plt.plot(xs, acc_matrix[:, i], marker="o", linewidth=2,
             label=f"Task {i+1}", color=LINE_COLORS[i])
plt.xlabel("After Training Task")
plt.ylabel("Accuracy")
plt.title("Forgetting Curve - Permuted MNIST")
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig(os.path.join(args.outdir, "forgetting_curve.png"), dpi=150)
plt.show()

# TBWT vs CBWT
plt.figure(figsize=(5, 4))
plt.bar(["TBWT", "CBWT"], [TBWT, CBWT], color=BAR_COLORS)
plt.title("TBWT vs CBWT")
plt.ylabel("Score")
plt.ylim(-1, 1)
plt.grid(axis="y", alpha=0.3)
plt.tight_layout()
plt.savefig(os.path.join(args.outdir, "tbwt_cbwt_bar.png"), dpi=150)
plt.show()

np.save(os.path.join(args.outdir, "accuracy_matrix.npy"), acc_matrix)
with open(os.path.join(args.outdir, "metrics.txt"), "w") as f:
    f.write(f"ACC : {ACC:.4f}\n")
    f.write(f"BWT : {BWT:.4f}\n")
    f.write(f"TBWT: {TBWT:.4f}\n")
    f.write(f"CBWT: {CBWT:.4f}\n")

print(f"\nResults and plots saved under {args.outdir}")